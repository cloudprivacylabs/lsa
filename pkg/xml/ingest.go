// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package xml

import (
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
)

var ErrExtraCharacters = errors.New("Extra characters before document")
var ErrMultipleRoots = errors.New("Multiple roots")
var ErrInvalidXML = errors.New("Invalid XML")

const XSDNamespace = "http://www.w3.org/2001/XMLSchema"

type ErrAmbiguousSchemaAttribute struct {
	Attr xml.Name
}

func (e ErrAmbiguousSchemaAttribute) Error() string {
	if len(e.Attr.Space) > 0 {
		return fmt.Sprintf("Ambiguous schema attribute for %s:%s", e.Attr.Space, e.Attr.Local)
	}
	return fmt.Sprintf("Ambiguous schema attribute for %s", e.Attr.Local)
}

type ErrElementNodeNotTerminated struct {
	Name xml.Name
}

func (e ErrElementNodeNotTerminated) Error() string {
	if len(e.Name.Space) > 0 {
		return fmt.Sprintf("Element not terminated: %s:%s", e.Name.Space, e.Name.Local)
	}
	return fmt.Sprintf("Element not terminated: %s", e.Name.Local)
}

// Ingester converts an XML object model into a graph using a schema
type Ingester struct {
	ls.Ingester

	Interner ls.Interner

	IncludeProcessingInstructions bool
	IncludeDirectives             bool
}

// IngestStream ingests an XML from the input stream
func IngestStream(ingester *Ingester, baseID string, input io.Reader) (ls.Node, error) {
	decoder := xml.NewDecoder(input)
	return ingester.IngestDocument(baseID, decoder)
}

// IngestDocument ingests an XML using the schema. The output will have all input
// nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) IngestDocument(baseID string, decoder *xml.Decoder) (ls.Node, error) {
	ingester.PreserveNodePaths = true
	if ingester.Interner == nil {
		ingester.Interner = ls.NewInterner()
	}
	path, schemaRoot := ingester.Start(baseID)
	wsFacet, _ := GetWhitespaceFacet("collapse")

	filterBOM := func(in []byte) []byte {
		if len(in) == 3 && in[0] == 0xEF && in[1] == 0xBB && in[2] == 0xBF {
			return []byte(" ")
		}
		return in
	}

	// At the top level there can be processing instructions,
	// directives, and the root element
	done := false
	rootSeen := false
	var rootNode ls.Node
	var err error
	for !done {
		var tok xml.Token
		tok, err = decoder.Token()
		if err != nil {
			break
		}
		switch token := tok.(type) {
		case xml.CharData:
			data := token.Copy()
			if !rootSeen {
				data = filterBOM(data)
			}
			if strings.TrimSpace(string(data)) != "" {
				return nil, ErrExtraCharacters
			}

		case xml.StartElement:
			// This is the document root
			if rootSeen {
				return nil, ErrMultipleRoots
			}
			rootSeen = true
			rn, err := ingester.parseElement(token, path, decoder, schemaRoot, wsFacet)
			if err != nil {
				return nil, err
			}
			rootNode = rn.node
			done = true

		case xml.Comment:

		case xml.Directive:

		case xml.ProcInst:

		default:
			return nil, ErrInvalidXML
		}
	}
	if err == io.EOF {
		err = nil
	}
	// Assign node IDs
	if ingester.Schema != nil {
		ls.AssignEntityIDs(rootNode, func(entity, ID string, node ls.Node, path []ls.Node) string {
			nodePath := ingester.NodePaths[node]
			eid := fmt.Sprintf("%s/%s", entity, ID)
			if len(nodePath) > 1 {
				eid += "/" + ls.NodePath(nodePath[1:]).String()
			}
			return eid
		})
	}

	return rootNode, err
}

type parsedElement struct {
	node  ls.Node
	token xml.Token
}

func (ingester *Ingester) parseElement(data xml.StartElement, path ls.NodePath, decoder *xml.Decoder, schemaNode ls.Node, wsFacet WhitespaceFacet) (parsedElement, error) {

	// Get all the possible child nodes from the schema. If the
	// schemaNode is nil, the returned schemaNodes will be empty
	schemaNodes, err := ingester.GetObjectAttributeNodes(schemaNode)
	if err != nil {
		return parsedElement{}, err
	}

	path = path.AppendString(data.Name.Local)

	// This finds the best mathcing schema attribute. If a schema
	// attribute is required for an XML attribute, requireAttr must be
	// true. Then, if the name matches a schema attribute with namespace
	// and lname, that attribute is returned. If there are no full-name
	// matches, a lname matching attribute tha does not specify
	// namespace will be returned.
	//
	// Example:
	//    name: abc
	//    schema attributes: ns:abc, abc -> abc will be returned
	//    name: ns:abc
	//    schema attributes: ns:abc, abc -> nc:abc will be returned
	findBestMatch := func(name xml.Name, attrs []ls.Node, requireAttr bool) (ls.Node, error) {
		var lnameMatch, fnameMatch ls.Node
		for _, attr := range attrs {
			_, attrTerm := attr.GetProperties()[AttributeTerm]
			if requireAttr != attrTerm {
				continue
			}
			ns := attr.GetProperties()[NamespaceTerm]
			if ns == nil {
				if lnameMatch != nil {
					return nil, ErrAmbiguousSchemaAttribute{Attr: name}
				}
				lnameMatch = attr
			} else if ns.IsString() {
				if ns.AsString() == name.Space {
					if fnameMatch != nil {
						return nil, ErrAmbiguousSchemaAttribute{Attr: name}
					}
					fnameMatch = attr
				}
			}
		}
		if lnameMatch != nil && fnameMatch != nil {
			return nil, ErrAmbiguousSchemaAttribute{Attr: name}
		}
		attrSchema := lnameMatch
		if attrSchema == nil {
			attrSchema = fnameMatch
		}
		return attrSchema, nil
	}

	attributeNodes := make([]ls.Node, 0)
	for index, attribute := range data.Attr {
		if IsWhitespaceFacet(attribute.Name) {
			wf, err := GetWhitespaceFacet(attribute.Value)
			if err != nil {
				return parsedElement{}, err
			}
			wsFacet = wf
		}

		var attrSchema ls.Node
		if schemaNode != nil {
			attrSchema, err = findBestMatch(attribute.Name, schemaNodes[attribute.Name.Local], true)
			if err != nil {
				return parsedElement{}, err
			}
		}

		attrNode, err := ingester.Value(append(path, fmt.Sprintf("attr-%d", index)), attrSchema, attribute.Value)
		if err != nil {
			return parsedElement{}, err
		}
		if len(attribute.Name.Space) > 0 {
			attrNode.GetProperties()[NamespaceTerm] = ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Space))
		}
		attrNode.GetProperties()[LocalNameTerm] = ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Local))
		attrNode.SetValue(attribute.Value)
		attributeNodes = append(attributeNodes, attrNode)
	}

	children := make([]parsedElement, 0)

	elementCounts := make(map[xml.Name]int)
	textNodeIndex := 0
	for {
		tok, err := decoder.Token()
		if err == io.EOF {
			return parsedElement{}, ErrElementNodeNotTerminated{data.Name}
		}
		if err != nil {
			return parsedElement{}, err
		}

		switch token := tok.(type) {
		case xml.StartElement:
			index := elementCounts[token.Name]
			elementCounts[token.Name] = index + 1

			var elemSchema ls.Node
			if schemaNode != nil {
				elemSchema, err = findBestMatch(token.Name, schemaNodes[token.Name.Local], false)
				if err != nil {
					return parsedElement{}, err
				}
			}

			node, err := ingester.parseElement(token, path.AppendInt(index), decoder, elemSchema, wsFacet)
			if err != nil {
				return parsedElement{}, err
			}
			children = append(children, node)

		case xml.EndElement:
			// Apply whitespace facet. At this point, all text nodes are
			// normalized. That means, there cannot be consecutive value
			// (text) nodes here
			w := 0
			hasNonTextNodes := false
			hasTextNodes := false
			for i := range children {
				if _, isCharData := children[i].token.(xml.CharData); isCharData {
					str := wsFacet.Filter(children[i].node.GetValue().(string))
					if len(str) != 0 {
						hasTextNodes = true
						children[i].node.SetValue(str)
						children[w] = children[i]
						w++
					}
				} else {
					hasNonTextNodes = true
					children[w] = children[i]
					w++
				}
			}

			var newNode ls.Node
			switch {
			case (hasNonTextNodes && hasTextNodes) || // Mixed content
				(hasNonTextNodes && !hasTextNodes): // Object
				childNodes := make([]ls.Node, 0, len(children))
				for _, x := range children[:w] {
					childNodes = append(childNodes, x.node)
				}
				newNode, err = ingester.Object(path, schemaNode, append(attributeNodes, childNodes...))

			case !hasNonTextNodes && !hasTextNodes: // No content
				if schemaNode != nil {
					if schemaNode.GetTypes().Has(ls.AttributeTypes.Value) {
						newNode, err = ingester.Value(path, schemaNode, nil)
					} else {
						newNode, err = ingester.Object(path, schemaNode, nil)
					}
				} else {
					newNode, err = ingester.Value(path, schemaNode, nil)
				}

			case !hasNonTextNodes && hasTextNodes: // Value
				newNode, err = ingester.Value(path, schemaNode, children[0].node.GetValue())
			}
			if err != nil {
				return parsedElement{}, err
			}

			properties := newNode.GetProperties()
			if len(data.Name.Space) > 0 {
				properties[NamespaceTerm] = ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Space))
			}
			properties[LocalNameTerm] = ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Local))
			return parsedElement{token: token, node: newNode}, nil

		case xml.CharData:
			data := string(token)
			// Nornalize text nodes so there is only one text node child per parent node
			// If last node is also chardata, merge
			merged := false
			if len(children) > 0 {
				last := children[len(children)-1]
				if _, isCharData := last.token.(xml.CharData); isCharData {
					last.node.SetValue(last.node.GetValue().(string) + data)
					merged = true
				}
			}
			if !merged {
				node, err := ingester.Value(path.AppendInt(textNodeIndex), nil, data)
				textNodeIndex++
				if err != nil {
					return parsedElement{}, err
				}
				children = append(children, parsedElement{token: token, node: node})
			}
		case xml.ProcInst:
		case xml.Directive:
		case xml.Comment:
		}
	}

}
