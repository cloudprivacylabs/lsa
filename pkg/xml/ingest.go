// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package xml

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
	"github.com/cloudprivacylabs/lsa/pkg/opencypher/graph"
)

var ErrExtraCharacters = errors.New("Extra characters before document")
var ErrMultipleRoots = errors.New("Multiple roots")
var ErrInvalidXML = errors.New("Invalid XML")

const XSDNamespace = "http://www.w3.org/2001/XMLSchema"

type ErrAmbiguousSchemaAttribute struct {
	Attr xml.Name
}

func (e ErrAmbiguousSchemaAttribute) Error() string {
	if len(e.Attr.Space) > 0 {
		return fmt.Sprintf("Ambiguous schema attribute for %s:%s", e.Attr.Space, e.Attr.Local)
	}
	return fmt.Sprintf("Ambiguous schema attribute for %s", e.Attr.Local)
}

type ErrElementNodeNotTerminated struct {
	Name xml.Name
}

func (e ErrElementNodeNotTerminated) Error() string {
	if len(e.Name.Space) > 0 {
		return fmt.Sprintf("Element not terminated: %s:%s", e.Name.Space, e.Name.Local)
	}
	return fmt.Sprintf("Element not terminated: %s", e.Name.Local)
}

// Ingester converts an XML object model into a graph using a schema
type Ingester struct {
	ls.Ingester

	Interner ls.Interner

	IncludeProcessingInstructions bool
	IncludeDirectives             bool
}

// IngestStream ingests an XML from the input stream
func IngestStream(context *ls.Context, ingester *Ingester, targetGraph graph.Graph, baseID string, input io.Reader) (graph.Node, error) {
	decoder := xml.NewDecoder(input)
	return ingester.IngestDocument(context, targetGraph, baseID, decoder)
}

// IngestDocument ingests an XML using the schema. The output will have all input
// nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) IngestDocument(context *ls.Context, targetGraph graph.Graph, baseID string, decoder *xml.Decoder) (graph.Node, error) {
	ingester.PreserveNodePaths = true
	if ingester.Interner == nil {
		ingester.Interner = ls.NewInterner()
	}
	path, schemaRoot := ingester.Start(context, baseID)
	wsFacet, _ := GetWhitespaceFacet("collapse")

	filterBOM := func(in []byte) []byte {
		if len(in) == 3 && in[0] == 0xEF && in[1] == 0xBB && in[2] == 0xBF {
			return []byte(" ")
		}
		return in
	}

	// At the top level there can be processing instructions,
	// directives, and the root element
	done := false
	rootSeen := false
	var rootNode graph.Node
	var err error
	for !done {
		var tok xml.Token
		tok, err = decoder.Token()
		if err != nil {
			break
		}
		switch token := tok.(type) {
		case xml.CharData:
			data := token.Copy()
			if !rootSeen {
				data = filterBOM(data)
			}
			if strings.TrimSpace(string(data)) != "" {
				return nil, ErrExtraCharacters
			}

		case xml.StartElement:
			// This is the document root
			if rootSeen {
				return nil, ErrMultipleRoots
			}
			rootSeen = true
			rn, err := ingester.parseElement(context, targetGraph, token, path, decoder, schemaRoot, wsFacet)
			if err != nil {
				return nil, err
			}
			rootNode = rn.node
			done = true

		case xml.Comment:

		case xml.Directive:

		case xml.ProcInst:

		default:
			return nil, ErrInvalidXML
		}
	}
	if err == io.EOF {
		err = nil
	}
	ingester.Finish(context, rootNode, nil)
	return rootNode, err
}

type parsedElement struct {
	node  graph.Node
	token xml.Token
}

func (ingester *Ingester) parseElement(context *ls.Context, targetGraph graph.Graph, data xml.StartElement, path ls.NodePath, decoder *xml.Decoder, schemaNode graph.Node, wsFacet WhitespaceFacet) (parsedElement, error) {
	// If schemaNode is nil and we are only ingesting known nodes, ignore this node
	if schemaNode == nil && ingester.OnlySchemaAttributes {
		return parsedElement{}, nil
	}
	// Get all the possible child nodes from the schema. If the
	// schemaNode is nil, the returned schemaNodes will be empty
	schemaNodes, err := ingester.GetObjectAttributeNodes(context, schemaNode)
	if err != nil {
		return parsedElement{}, err
	}

	path = path.AppendString(data.Name.Local)

	// This finds the best mathcing schema attribute. If a schema
	// attribute is required for an XML attribute, requireAttr must be
	// true. Then, if the name matches a schema attribute with namespace
	// and lname, that attribute is returned. If there are no full-name
	// matches, a lname matching attribute tha does not specify
	// namespace will be returned.
	//
	// Example:
	//    name: abc
	//    schema attributes: ns:abc, abc -> abc will be returned
	//    name: ns:abc
	//    schema attributes: ns:abc, abc -> nc:abc will be returned
	findBestMatch := func(name xml.Name, attrs []graph.Node, requireAttr bool) (graph.Node, error) {
		var lnameMatch, fnameMatch graph.Node
		for _, attr := range attrs {
			_, attrTerm := attr.GetProperty(AttributeTerm)
			if requireAttr != attrTerm {
				continue
			}
			ns := ls.AsPropertyValue(attr.GetProperty(NamespaceTerm))
			if ns == nil {
				if lnameMatch != nil {
					return nil, ErrAmbiguousSchemaAttribute{Attr: name}
				}
				lnameMatch = attr
			} else if ns.IsString() {
				if ns.AsString() == name.Space {
					if fnameMatch != nil {
						return nil, ErrAmbiguousSchemaAttribute{Attr: name}
					}
					fnameMatch = attr
				}
			}
		}
		if lnameMatch != nil && fnameMatch != nil {
			return nil, ErrAmbiguousSchemaAttribute{Attr: name}
		}
		attrSchema := lnameMatch
		if attrSchema == nil {
			attrSchema = fnameMatch
		}
		return attrSchema, nil
	}

	attributeNodes := make([]graph.Node, 0)
	for index, attribute := range data.Attr {
		if !ingester.IngestEmptyValues && len(attribute.Value) == 0 {
			continue
		}
		if IsWhitespaceFacet(attribute.Name) {
			wf, err := GetWhitespaceFacet(attribute.Value)
			if err != nil {
				return parsedElement{}, err
			}
			wsFacet = wf
		}

		var attrSchema graph.Node
		if schemaNode != nil {
			attrSchema, err = findBestMatch(attribute.Name, schemaNodes[attribute.Name.Local], true)
			if err != nil {
				return parsedElement{}, err
			}
		}

		attrNode, err := ingester.Value(context, targetGraph, append(path, fmt.Sprintf("attr-%d", index)), attrSchema, attribute.Value)
		if err != nil {
			return parsedElement{}, err
		}
		if len(attribute.Name.Space) > 0 {
			attrNode.SetProperty(NamespaceTerm, ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Space)))
		}
		attrNode.SetProperty(LocalNameTerm, ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Local)))
		ls.SetRawNodeValue(attrNode, attribute.Value)
		attributeNodes = append(attributeNodes, attrNode)
	}

	children := make([]parsedElement, 0)

	elementCounts := make(map[xml.Name]int)
	for {
		tok, err := decoder.Token()
		if err == io.EOF {
			return parsedElement{}, ErrElementNodeNotTerminated{data.Name}
		}
		if err != nil {
			return parsedElement{}, err
		}

		switch token := tok.(type) {
		case xml.StartElement:
			index := elementCounts[token.Name]
			elementCounts[token.Name] = index + 1

			var elemSchema graph.Node
			if schemaNode != nil {
				elemSchema, err = findBestMatch(token.Name, schemaNodes[token.Name.Local], false)
				if err != nil {
					return parsedElement{}, err
				}
			}

			node, err := ingester.parseElement(context, targetGraph, token, path.AppendInt(index), decoder, elemSchema, wsFacet)
			if err != nil {
				return parsedElement{}, err
			}
			if node.node != nil {
				children = append(children, node)
			}

		case xml.EndElement:
			// Normalize text nodes
			hasNonTextNodes := false
			hasTextNodes := false
			w := 0
			var accumulatedText *bytes.Buffer
			for i := range children {
				if ch, chardata := children[i].token.(xml.CharData); chardata {
					if accumulatedText == nil {
						accumulatedText = &bytes.Buffer{}
					}
					accumulatedText.Write(ch)
				} else {
					if accumulatedText != nil {
						children[w] = parsedElement{token: xml.CharData(accumulatedText.Bytes())}
						w++
						accumulatedText = nil
					}
					children[w] = children[i]
					w++
					hasNonTextNodes = true
				}
			}
			if accumulatedText != nil {
				children[w] = parsedElement{token: xml.CharData(accumulatedText.Bytes())}
				w++
			}
			children = children[:w]

			// Apply wsfacet and create text nodes
			w = 0
			for i := range children {
				if chardata, isCharData := children[i].token.(xml.CharData); isCharData {
					str := wsFacet.Filter(string(chardata))
					if len(str) != 0 {
						hasTextNodes = true
						children[w] = children[i]
						children[w].token = xml.CharData(str)

						// children[w].node, err = ingester.Value(targetGraph, path, schemaNode, nil)
						// if err != nil {
						// 	return parsedElement{}, err
						// }
						// ls.SetNodeIndex(children[w].node, i)
						// ls.SetRawNodeValue(children[i].node, str)
						w++
					}
				} else {
					children[w] = children[i]
					w++
				}
			}
			children = children[:w]

			var newNode graph.Node
			switch {
			case (hasNonTextNodes && hasTextNodes) || // Mixed content
				(hasNonTextNodes && !hasTextNodes): // Object, Array
				childNodes := make([]graph.Node, 0, len(children))
				for i, x := range children {
					node := x.node
					if node == nil {
						node, err = ingester.Value(context, targetGraph, path, schemaNode, string(children[i].token.(xml.CharData)))
						if err != nil {
							return parsedElement{}, err
						}
						ls.SetNodeIndex(node, i)
					}
					childNodes = append(childNodes, node)
				}
				if schemaNode != nil && schemaNode.GetLabels().Has(ls.AttributeTypeArray) {
					newNode, err = ingester.Array(context, targetGraph, path, schemaNode, append(attributeNodes, childNodes...))
				} else {
					newNode, err = ingester.Object(context, targetGraph, path, schemaNode, append(attributeNodes, childNodes...))
				}
			case !hasNonTextNodes && !hasTextNodes: // No content
				if schemaNode != nil {
					if schemaNode.GetLabels().Has(ls.AttributeTypeValue) {
						newNode, err = ingester.Value(context, targetGraph, path, schemaNode, nil)
					} else if schemaNode.GetLabels().Has(ls.AttributeTypeArray) {
						newNode, err = ingester.Array(context, targetGraph, path, schemaNode, nil)
					} else {
						newNode, err = ingester.Object(context, targetGraph, path, schemaNode, nil)
					}
				} else {
					newNode, err = ingester.Value(context, targetGraph, path, schemaNode, nil)
				}

			case !hasNonTextNodes && hasTextNodes: // Value, there is only one child
				str := string(children[0].token.(xml.CharData))
				node, err := ingester.Value(context, targetGraph, path, schemaNode, str)
				if err != nil {
					return parsedElement{}, err
				}
				if schemaNode != nil && schemaNode.GetLabels().Has(ls.AttributeTypeArray) {
					newNode, err = ingester.Array(context, targetGraph, path, schemaNode, []graph.Node{node})
				} else {
					newNode = node
				}
			}
			if err != nil {
				return parsedElement{}, err
			}

			if len(data.Name.Space) > 0 {
				newNode.SetProperty(NamespaceTerm, ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Space)))
			}
			newNode.SetProperty(LocalNameTerm, ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Local)))
			return parsedElement{token: token, node: newNode}, nil

		case xml.CharData:
			// Do not create a node for chardata at this point
			newTok := make(xml.CharData, len(token))
			copy(newTok, token)
			children = append(children, parsedElement{token: newTok})

		case xml.ProcInst:
		case xml.Directive:
		case xml.Comment:
		}
	}

}
