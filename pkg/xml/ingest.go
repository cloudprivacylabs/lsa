// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package xml

import (
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
)

var ErrExtraCharacters = errors.New("Extra characters before document")
var ErrMultipleRoots = errors.New("Multiple roots")
var ErrInvalidXML = errors.New("Invalid XML")

type ErrElementNodeNotTerminated struct {
	Name xml.Name
}

func (e ErrElementNodeNotTerminated) Error() string {
	if len(e.Name.Space) > 0 {
		return fmt.Sprintf("Element not terminated: %s:%s", e.Name.Space, e.Name.Local)
	}
	return fmt.Sprintf("Element not terminated: %s", e.Name.Local)
}

// Ingester converts an XML object model into a graph using a schema
type Ingester struct {
	ls.Ingester

	Interner ls.Interner

	IncludeProcessingInstructions bool
	IncludeDirectives             bool
}

// IngestStream ingests an XML from the input stream
func IngestStream(ingester *Ingester, baseID string, input io.Reader) (ls.Node, error) {
	decoder := xml.NewDecoder(input)
	return ingester.IngestDocument(baseID, decoder)
}

// IngestDocument inygests an XML using the schema. The output will have all input
// nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) IngestDocument(baseID string, decoder *xml.Decoder) (ls.Node, error) {
	if ingester.Interner == nil {
		ingester.Interner = ls.NewInterner()
	}
	path, schemaRoot := ingester.Start(baseID)

	filterBOM := func(in []byte) []byte {
		if len(in) == 3 && in[0] == 0xEF && in[1] == 0xBB && in[2] == 0xBF {
			return []byte(" ")
		}
		return in
	}

	// At the top level there can be processing instructions,
	// directives, and the root element
	done := false
	rootSeen := false
	var rootNode ls.Node
	var err error
	for !done {
		var tok xml.Token
		tok, err = decoder.Token()
		if err != nil {
			break
		}
		switch token := tok.(type) {
		case xml.CharData:
			data := token.Copy()
			if !rootSeen {
				data = filterBOM(data)
			}
			if strings.TrimSpace(string(data)) != "" {
				return nil, ErrExtraCharacters
			}

		case xml.StartElement:
			// This is the document root
			if rootSeen {
				return nil, ErrMultipleRoots
			}
			rootSeen = true
			rootNode, err = ingester.parseElement(token, path, decoder, schemaRoot)
			if err != nil {
				return nil, err
			}
			done = true

		case xml.Comment:

		case xml.Directive:

		case xml.ProcInst:

		default:
			return nil, ErrInvalidXML
		}
	}
	if err == io.EOF {
		err = nil
	}

	return rootNode, err
}

func (ingester *Ingester) parseElement(data xml.StartElement, path []interface{}, decoder *xml.Decoder, schemaNode ls.Node) (ls.Node, error) {

	path = append(path, data.Name.Local)

	attributeNodes := make([]ls.Node, 0)
	for index, attribute := range data.Attr {
		attrNode, err := ingester.Value(append(path, fmt.Sprintf("attr-%d", index)), nil, attribute.Value)
		if err != nil {
			return nil, err
		}
		if len(attribute.Name.Space) > 0 {
			attrNode.GetProperties()[NamespaceTerm] = ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Space))
		}
		attrNode.GetProperties()[LocalNameTerm] = ls.StringPropertyValue(ingester.Interner.Intern(attribute.Name.Local))
		attrNode.SetValue(attribute.Value)
		attributeNodes = append(attributeNodes, attrNode)
	}
	newNode, err := ingester.Object(path, schemaNode, attributeNodes)
	if err != nil {
		return nil, err
	}
	properties := newNode.GetProperties()
	if len(data.Name.Space) > 0 {
		properties[NamespaceTerm] = ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Space))
	}
	properties[LocalNameTerm] = ls.StringPropertyValue(ingester.Interner.Intern(data.Name.Local))

	children := make([]ls.Node, 0)

	elementCounts := make(map[xml.Name]int)
	textNodeIndex := 0
	for {
		tok, err := decoder.Token()
		if err == io.EOF {
			return nil, ErrElementNodeNotTerminated{data.Name}
		}
		if err != nil {
			return nil, err
		}

		switch token := tok.(type) {
		case xml.StartElement:
			index := elementCounts[token.Name]
			elementCounts[token.Name] = index + 1
			node, err := ingester.parseElement(token, append(path, index), decoder, nil)
			if err != nil {
				return nil, err
			}
			children = append(children, node)

		case xml.EndElement:
			ingester.ConnectChildNodes(newNode, children)
			return newNode, nil

		case xml.CharData:
			data := string(token)
			node, err := ingester.Value(append(path, textNodeIndex), nil, data)
			textNodeIndex++
			if err != nil {
				return nil, err
			}
			children = append(children, node)
		case xml.ProcInst:
		case xml.Directive:
		case xml.Comment:
		}
	}
}
