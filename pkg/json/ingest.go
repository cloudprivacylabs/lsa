// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package json

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"github.com/bserdar/jsonom"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
)

// Ingester converts a JSON object model into a graph using a schema
type Ingester struct {
	ls.Ingester

	Interner ls.Interner
}

// IngestBytes ingests JSON bytes
func IngestBytes(ingester *Ingester, baseID string, input []byte) (ls.Node, error) {
	return IngestStream(ingester, baseID, bytes.NewReader(input))
}

// IngestStream ingests JSON stream
func IngestStream(ingester *Ingester, baseID string, input io.Reader) (ls.Node, error) {
	node, err := jsonom.UnmarshalReader(input, ingester.Interner)
	if err != nil {
		return nil, err
	}
	return ingester.Ingest(baseID, node)
}

// Ingest a json document using the schema. The output will have all
// input nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) Ingest(baseID string, input jsonom.Node) (ls.Node, error) {
	path, root := ingester.Start(baseID)
	dn, err := ingester.ingest(input, path, root)
	if err != nil {
		return nil, err
	}
	return dn, err
}

func (ingester *Ingester) ingest(input jsonom.Node, path []interface{}, schemaNode ls.Node) (ls.Node, error) {

	validate := func(node ls.Node, err error) (ls.Node, error) {
		if err != nil {
			return nil, err
		}
		if err := ingester.Validate(node, schemaNode); err != nil {
			return nil, err
		}
		return node, nil
	}

	if schemaNode != nil && schemaNode.GetTypes().Has(ls.AttributeTypes.Polymorphic) {
		return validate(ingester.ingestPolymorphicNode(input, path, schemaNode))
	}
	switch next := input.(type) {
	case *jsonom.Object:
		return validate(ingester.ingestObject(next, path, schemaNode))
	case *jsonom.Array:
		return validate(ingester.ingestArray(next, path, schemaNode))
	}
	return validate(ingester.ingestValue(input.(*jsonom.Value), path, schemaNode))
}

func (ingester *Ingester) ingestPolymorphicNode(input jsonom.Node, path []interface{}, schemaNode ls.Node) (ls.Node, error) {
	return ingester.Polymorphic(path, schemaNode, func(p []interface{}, optionNode ls.Node) (ls.Node, error) {
		return ingester.ingest(input, p, optionNode)
	})
}

func (ingester *Ingester) ingestObject(input *jsonom.Object, path []interface{}, schemaNode ls.Node) (ls.Node, error) {
	// An object node
	// There is a schema node for this node. It must be an object
	nextNodes, err := ingester.GetObjectAttributeNodes(schemaNode)
	if err != nil {
		return nil, err
	}
	elements := make([]ls.Node, 0, input.Len())
	for i := 0; i < input.Len(); i++ {
		keyValue := input.N(i)
		childNode, err := ingester.ingest(keyValue.Value(), append(path, keyValue.Key()), nextNodes[keyValue.Key()])
		if err != nil {
			return nil, ls.ErrDataIngestion{Key: keyValue.Key(), Err: err}
		}
		childNode.GetProperties()[ls.AttributeNameTerm] = ls.StringPropertyValue(keyValue.Key())
		elements = append(elements, childNode)
	}
	return ingester.Object(path, schemaNode, elements, ObjectTypeTerm)
}

func (ingester *Ingester) ingestArray(input *jsonom.Array, path []interface{}, schemaNode ls.Node) (ls.Node, error) {
	elementsNode := ingester.GetArrayElementNode(schemaNode)
	elements := make([]ls.Node, 0, input.Len())
	for index := 0; index < input.Len(); index++ {
		childNode, err := ingester.ingest(input.N(index), append(path, index), elementsNode)
		if err != nil {
			return nil, ls.ErrDataIngestion{Key: fmt.Sprint(index), Err: err}
		}
		childNode.GetProperties()[ls.AttributeIndexTerm] = ls.StringPropertyValue(fmt.Sprint(index))
		elements = append(elements, childNode)
	}
	return ingester.Array(path, schemaNode, elements, ArrayTypeTerm)
}

func (ingester *Ingester) ingestValue(input *jsonom.Value, path []interface{}, schemaNode ls.Node) (ls.Node, error) {
	var value interface{}
	var typ string
	if input.Value() != nil {
		switch v := input.Value().(type) {
		case bool:
			value = fmt.Sprint(v)
			typ = BooleanTypeTerm
		case string:
			value = v
			typ = StringTypeTerm
		case uint8, uint16, uint32, uint64, int8, int16, int32, int64, int, uint, float32, float64:
			value = fmt.Sprint(input.Value())
			typ = NumberTypeTerm
		case json.Number:
			value = string(v)
			typ = NumberTypeTerm
		default:
			value = fmt.Sprint(v)
		}
	}
	return ingester.Value(path, schemaNode, value, typ)
}
