// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package json

import (
	"fmt"
	"strings"

	"github.com/bserdar/digraph"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
)

type Ingester struct {
	Schema *ls.Layer

	// This is the schema node property containing the JSON key.
	//
	// If the schema defines KeyTerm: x, then the schema object matches
	// the JSON key x
	KeyTerm string

	// NewNodeFunc will create a new node for the data graph with the
	// given ID. If NewNodeFunc is nil, a ls.BasicDocumentNode will be
	// created. The function should not add the node to the graph.
	NewNodeFunc func(string) ls.Node

	// NewEdgeFunc will create a new edge for the data graph with the
	// given label. If NewEdgeFunc is nil, a ls.Edge will be
	// created. The function should not add the edge to the graph.
	NewEdgeFunc func(string) ls.Edge

	NodeIDGeneratorFunc func(input interface{}, path []interface{}, schemaNode ls.Node) string
}

type ErrSchemaValidation string

func (e ErrSchemaValidation) Error() string { return "Schema validation error: " + string(e) }

type ErrInvalidSchema string

func (e ErrInvalidSchema) Error() string { return "Invalid schema: " + string(e) }

type ErrDataIngestion struct {
	Key string
	Err error
}

func (e ErrDataIngestion) Error() string {
	return fmt.Sprintf("Data ingestion error: Key: %s - %s", e.Key, e.Err)
}

func (e ErrDataIngestion) Unwrap() error { return e.Err }

func pathToString(path []interface{}) string {
	components := make([]string, 0, len(path)+1)
	for _, x := range path {
		components = append(components, fmt.Sprint(x))
	}
	return strings.Join(components, ".")
}

// DefaultNodeIDGenerator returns Ingester.Schema.ID + join(path,".")
func (ingester *Ingester) DefaultNodeIDGenerator(input interface{}, path []interface{}, schemaNode ls.Node) string {
	return pathToString(path)
}

// Ingest a json document using the schema. The output will have all
// input nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) Ingest(target *digraph.Graph, baseID string, input interface{}) (ls.Node, error) {
	if input == nil {
		return nil, nil
	}

	path := make([]interface{}, 0, 16)
	path = append(path, baseID)
	var root ls.Node
	if ingester.Schema != nil {
		root = ingester.Schema.GetSchemaRootNode()
	}
	dn, err := ingester.ingest(target, input, path, root)
	if err != nil {
		return nil, err
	}
	target.AddNode(dn.node)
	ingester.link(dn)
	return dn.node, err
}

type addedNode struct {
	node       ls.Node
	schemaNode ls.Node
	children   []*addedNode
	term       string
}

func (ingester *Ingester) link(a *addedNode) {
	ingester.linkNode(a)
	for _, c := range a.children {
		ingester.link(c)
		ingester.connect(a.node, c.node, a.term)
	}
}

func (ingester *Ingester) linkNode(a *addedNode) {
	if a.schemaNode != nil {
		a.node.GetTypes().Add(ls.FilterNonLayerTypes(a.schemaNode.GetTypes().Slice())...)
		ingester.connect(a.node, a.schemaNode, ls.InstanceOfTerm)
	}
}

func (ingester *Ingester) ingest(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.Node) (*addedNode, error) {

	validate := func(newNode *addedNode, err error) (*addedNode, error) {
		if err != nil {
			return nil, err
		}
		if schemaNode != nil {
			if err := ls.ValidateDocumentNodeBySchema(newNode.node, schemaNode); err != nil {
				return nil, err
			}
		}
		return newNode, nil
	}

	if schemaNode != nil && schemaNode.GetTypes().Has(ls.AttributeTypes.Polymorphic) {
		return validate(ingester.ingestPolymorphicNode(target, input, path, schemaNode))
	}
	if m, ok := input.(map[string]interface{}); ok {
		return validate(ingester.ingestObject(target, m, path, schemaNode))
	}
	if a, ok := input.([]interface{}); ok {
		return validate(ingester.ingestArray(target, a, path, schemaNode))
	}
	return validate(ingester.ingestValue(target, input, path, schemaNode))
}

func (ingester *Ingester) ingestPolymorphicNode(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.Node) (*addedNode, error) {
	// Polymorphic node. Try each option
	var newChild *addedNode
	for nodes := schemaNode.GetAllOutgoingEdgesWithLabel(ls.LayerTerms.OneOf).Targets(); nodes.HasNext(); {
		optionNode := nodes.Next().(ls.Node)
		childNode, err := ingester.ingest(target, input, path, optionNode)
		if err == nil {
			if newChild != nil {
				return nil, ErrSchemaValidation("Multiple options of the polymorphic node matched:" + schemaNode.GetID())
			}
			newChild = childNode
		}
	}
	if newChild == nil {
		return nil, ErrSchemaValidation("None of the options of the polymorphic node matched:" + schemaNode.GetID())
	}
	return newChild, nil
}

func (ingester *Ingester) ingestObject(target *digraph.Graph, input map[string]interface{}, path []interface{}, schemaNode ls.Node) (*addedNode, error) {
	// An object node
	nextNodes := make(map[string]ls.Node)
	// There is a schema node for this node. It must be an object
	if schemaNode != nil {
		if !schemaNode.GetTypes().Has(ls.AttributeTypes.Object) {
			return nil, ErrSchemaValidation("A JSON object is not expected here")
		}

		addNextNode := func(node ls.Node) error {
			key := node.GetProperties()[ingester.KeyTerm].AsString()
			if len(key) == 0 {
				return ErrInvalidSchema(fmt.Sprintf("No '%s' in schema at %s path: %s", ingester.KeyTerm, node.GetID(), pathToString(path)))
			}
			if _, ok := nextNodes[key]; ok {
				return ErrInvalidSchema(fmt.Sprintf("Multiple elements with key '%s' path %s", key, pathToString(path)))
			}
			nextNodes[key] = node
			return nil
		}
		for nodes := schemaNode.GetAllOutgoingEdgesWithLabel(ls.LayerTerms.Attributes).Targets(); nodes.HasNext(); {
			if err := addNextNode(nodes.Next().(ls.Node)); err != nil {
				return nil, err
			}
		}
		for nodes := schemaNode.GetAllOutgoingEdgesWithLabel(ls.LayerTerms.AttributeList).Targets(); nodes.HasNext(); {
			if err := addNextNode(nodes.Next().(ls.Node)); err != nil {
				return nil, err
			}
		}
	}
	ret := &addedNode{node: ingester.newNode(ingester.generateID(input, path, schemaNode)),
		schemaNode: schemaNode,
		term:       ls.DataEdgeTerms.ObjectAttributes,
	}

	for key, value := range input {
		childNode, err := ingester.ingest(target, value, append(path, key), nextNodes[key])
		if err != nil {
			return nil, ErrDataIngestion{Key: key, Err: err}
		}
		childNode.node.GetProperties()[ls.AttributeNameTerm] = ls.StringPropertyValue(key)
		ret.children = append(ret.children, childNode)
	}
	return ret, nil
}

func (ingester *Ingester) ingestArray(target *digraph.Graph, input []interface{}, path []interface{}, schemaNode ls.Node) (*addedNode, error) {
	var elements ls.Node
	if schemaNode != nil {
		if !schemaNode.GetTypes().Has(ls.AttributeTypes.Array) {
			return nil, ErrSchemaValidation("A JSON array is not expected here")
		}
		n := schemaNode.Next(ls.LayerTerms.ArrayItems)
		if n != nil {
			elements = n.(ls.Node)
		}
	}
	ret := &addedNode{node: ingester.newNode(ingester.generateID(input, path, schemaNode)),
		schemaNode: schemaNode,
		term:       ls.DataEdgeTerms.ArrayElements,
	}
	for index := range input {
		childNode, err := ingester.ingest(target, input[index], append(path, index), elements)
		if err != nil {
			return nil, ErrDataIngestion{Key: fmt.Sprint(index), Err: err}
		}
		childNode.node.GetProperties()[ls.AttributeIndexTerm] = ls.StringPropertyValue(fmt.Sprint(index))
		ret.children = append(ret.children, childNode)
	}
	return ret, nil
}

func (ingester *Ingester) ingestValue(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.Node) (*addedNode, error) {
	if schemaNode != nil {
		if !schemaNode.GetTypes().Has(ls.AttributeTypes.Value) {
			return nil, ErrSchemaValidation("A JSON value is not expected here")
		}
	}
	newNode := ingester.newNode(ingester.generateID(input, path, schemaNode))
	newNode.SetValue(input)
	return &addedNode{node: newNode, schemaNode: schemaNode}, nil
}

func (ingester *Ingester) newNode(ID string) ls.Node {
	var node ls.Node
	if ingester.NewNodeFunc != nil {
		node = ingester.NewNodeFunc(ID)
	} else {
		node = ls.NewNode(ID)
	}
	node.GetTypes().Add(ls.DocumentNodeTerm)
	return node
}

func (ingester *Ingester) generateID(input interface{}, path []interface{}, schemaNode ls.Node) string {
	if ingester.NodeIDGeneratorFunc != nil {
		return ingester.NodeIDGeneratorFunc(input, path, schemaNode)
	}
	return ingester.DefaultNodeIDGenerator(input, path, schemaNode)
}

func (ingester *Ingester) connect(srcNode, targetNode digraph.Node, edgeLabel string) digraph.Edge {
	var edge digraph.Edge
	if ingester.NewEdgeFunc != nil {
		edge = ingester.NewEdgeFunc(edgeLabel)
	} else {
		edge = ls.NewEdge(edgeLabel)
	}
	digraph.Connect(srcNode, targetNode, edge)
	return edge
}
