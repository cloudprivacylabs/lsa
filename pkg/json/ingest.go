// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package json

import (
	"fmt"
	"strings"

	"github.com/bserdar/digraph"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
)

type Ingester struct {
	Schema *ls.Layer

	// This is the schema node property containing the JSON key.
	//
	// If the schema defines KeyTerm: x, then the schema object matches
	// the JSON key x
	KeyTerm string

	// NewNodeFunc will create a new node for the data graph with the
	// given ID. If NewNodeFunc is nil, a ls.BasicDocumentNode will be
	// created. The function should not add the node to the graph.
	NewNodeFunc func(string) ls.DocumentNode

	// NewEdgeFunc will create a new edge for the data graph with the
	// given label. If NewEdgeFunc is nil, a digraph.BasicEdge will be
	// created. The function should not add the edge to the graph.
	NewEdgeFunc func(string) digraph.Edge

	NodeIDGeneratorFunc func(input interface{}, path []interface{}, schemaNode ls.LayerNode) string
}

type ErrSchemaValidation string

func (e ErrSchemaValidation) Error() string { return "Schema validation error: " + string(e) }

type ErrInvalidSchema string

func (e ErrInvalidSchema) Error() string { return "Invalid schema: " + string(e) }

type ErrDataIngestion struct {
	Key string
	Err error
}

func (e ErrDataIngestion) Error() string {
	return fmt.Sprintf("Data ingestion error: Key: %s - %s", e.Key, e.Err)
}

func (e ErrDataIngestion) Unwrap() error { return e.Err }

// DefaultNodeIDGenerator returns Ingester.Schema.ID + join(path,".")
func (ingester *Ingester) DefaultNodeIDGenerator(input interface{}, path []interface{}, schemaNode ls.LayerNode) string {
	components := make([]string, 0, len(path)+1)
	for _, x := range path {
		components = append(components, fmt.Sprint(x))
	}
	return strings.Join(components, ".")
}

// Ingest a json document using the schema. The output will have all
// input nodes associated with schema nodes.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
func (ingester *Ingester) Ingest(target *digraph.Graph, baseID string, input interface{}) (ls.DocumentNode, error) {
	if input == nil {
		return nil, nil
	}

	path := make([]interface{}, 0, 16)
	path = append(path, baseID)
	var root ls.LayerNode
	if ingester.Schema != nil {
		root = ingester.Schema.GetObjectInfoNode()
	}
	return ingester.ingest(target, input, path, root)
}

func (ingester *Ingester) ingest(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.LayerNode) (ls.DocumentNode, error) {

	validate := func(newNode ls.DocumentNode, err error) (ls.DocumentNode, error) {
		if schemaNode != nil {
			if err := ls.ValidateDocumentNodeBySchema(newNode, schemaNode); err != nil {
				return nil, err
			}
		}
		return newNode, nil
	}

	if schemaNode != nil && schemaNode.HasType(ls.AttributeTypes.Polymorphic) {
		return validate(ingester.ingestPolymorphicNode(target, input, path, schemaNode))
	}
	if m, ok := input.(map[string]interface{}); ok {
		return validate(ingester.ingestObject(target, m, path, schemaNode))
	}
	if a, ok := input.([]interface{}); ok {
		return validate(ingester.ingestArray(target, a, path, schemaNode))
	}
	return validate(ingester.ingestValue(target, input, path, schemaNode))
}

func (ingester *Ingester) ingestPolymorphicNode(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.LayerNode) (ls.DocumentNode, error) {
	// Polymorphic node. Try each option
	var selectedOption ls.LayerNode
	var newChild ls.DocumentNode
	for nodes := schemaNode.AllOutgoingEdgesWithLabel(ls.LayerTerms.OneOf).Targets(); nodes.HasNext(); {
		optionNode := nodes.Next().(ls.LayerNode)
		childNode, err := ingester.ingest(target, input, path, optionNode)
		if err == nil {
			if selectedOption != nil {
				return nil, ErrSchemaValidation("Multiple options of the polymorphic node matched:" + schemaNode.GetID())
			}
			selectedOption = optionNode
			newChild = childNode
		}
	}
	if selectedOption == nil {
		return nil, ErrSchemaValidation("None of the options of the polymorphic node matched:" + schemaNode.GetID())
	}
	ingester.connect(newChild, selectedOption, ls.InstanceOfTerm)
	return newChild, nil
}

func (ingester *Ingester) ingestObject(target *digraph.Graph, input map[string]interface{}, path []interface{}, schemaNode ls.LayerNode) (ls.DocumentNode, error) {
	// An object node
	nextNodes := make(map[string]ls.LayerNode)
	// There is a schema node for this node. It must be an object
	if schemaNode != nil {
		if !schemaNode.HasType(ls.AttributeTypes.Object) {
			return nil, ErrSchemaValidation("A JSON object is not expected here")
		}

		addNextNode := func(node ls.LayerNode) error {
			key := node.GetPropertyMap()[ingester.KeyTerm].AsString()
			if len(key) == 0 {
				return ErrInvalidSchema(fmt.Sprintf("No '%s' in schema", ingester.KeyTerm))
			}
			if _, ok := nextNodes[key]; ok {
				return ErrInvalidSchema(fmt.Sprintf("Multiple elements with key '%s'", key))
			}
			nextNodes[key] = node
			return nil
		}
		for nodes := schemaNode.AllOutgoingEdgesWithLabel(ls.LayerTerms.Attributes).Targets(); nodes.HasNext(); {
			if err := addNextNode(nodes.Next().(ls.LayerNode)); err != nil {
				return nil, err
			}
		}
		for nodes := schemaNode.AllOutgoingEdgesWithLabel(ls.LayerTerms.AttributeList).Targets(); nodes.HasNext(); {
			if err := addNextNode(nodes.Next().(ls.LayerNode)); err != nil {
				return nil, err
			}
		}
	}
	newNode := ingester.newNode(ingester.generateID(input, path, schemaNode))
	target.AddNode(newNode)
	if schemaNode != nil {
		ingester.connect(newNode, schemaNode, ls.InstanceOfTerm)
	}

	for key, value := range input {
		childNode, err := ingester.ingest(target, value, append(path, key), nextNodes[key])
		if err != nil {
			return nil, ErrDataIngestion{Key: key, Err: err}
		}
		childNode.SetProperty(ls.AttributeNameTerm, key)
		ingester.connect(newNode, childNode, ls.DataEdgeTerms.ObjectAttributes)
	}
	return newNode, nil
}

func (ingester *Ingester) ingestArray(target *digraph.Graph, input []interface{}, path []interface{}, schemaNode ls.LayerNode) (ls.DocumentNode, error) {
	var elements ls.LayerNode
	if schemaNode != nil {
		if !schemaNode.HasType(ls.AttributeTypes.Array) {
			return nil, ErrSchemaValidation("A JSON array is not expected here")
		}
		n := schemaNode.NextNode(ls.LayerTerms.ArrayItems)
		if n != nil {
			elements = n.(ls.LayerNode)
		}
	}
	newNode := ingester.newNode(ingester.generateID(input, path, schemaNode))
	target.AddNode(newNode)
	if schemaNode != nil {
		ingester.connect(newNode, schemaNode, ls.InstanceOfTerm)
	}
	for index := range input {
		childNode, err := ingester.ingest(target, input[index], append(path, index), elements)
		if err != nil {
			return nil, ErrDataIngestion{Key: fmt.Sprint(index), Err: err}
		}
		childNode.SetProperty(ls.AttributeIndexTerm, index)
		ingester.connect(newNode, childNode, ls.DataEdgeTerms.ArrayElements)
	}
	return newNode, nil
}

func (ingester *Ingester) ingestValue(target *digraph.Graph, input interface{}, path []interface{}, schemaNode ls.LayerNode) (ls.DocumentNode, error) {
	if schemaNode != nil {
		if !schemaNode.HasType(ls.AttributeTypes.Value) {
			return nil, ErrSchemaValidation("A JSON value is not expected here")
		}
	}
	newNode := ingester.newNode(ingester.generateID(input, path, schemaNode))
	target.AddNode(newNode)
	if schemaNode != nil {
		ingester.connect(newNode, schemaNode, ls.InstanceOfTerm)
	}
	newNode.SetValue(input)
	return newNode, nil
}

func (ingester *Ingester) newNode(ID string) ls.DocumentNode {
	if ingester.NewNodeFunc != nil {
		return ingester.NewNodeFunc(ID)
	}
	return ls.NewBasicDocumentNode(ID)
}

func (ingester *Ingester) generateID(input interface{}, path []interface{}, schemaNode ls.LayerNode) string {
	if ingester.NodeIDGeneratorFunc != nil {
		return ingester.NodeIDGeneratorFunc(input, path, schemaNode)
	}
	return ingester.DefaultNodeIDGenerator(input, path, schemaNode)
}

func (ingester *Ingester) connect(srcNode, targetNode digraph.Node, edgeLabel string) digraph.Edge {
	var edge digraph.Edge
	if ingester.NewEdgeFunc != nil {
		edge = ingester.NewEdgeFunc(edgeLabel)
	} else {
		edge = digraph.NewBasicEdge(edgeLabel, nil)
	}
	srcNode.GetGraph().AddEdge(srcNode, targetNode, edge)
	return edge
}
