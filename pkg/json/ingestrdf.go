// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package json

import (
	"fmt"
	"strconv"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
	"github.com/cloudprivacylabs/lsa/pkg/rdf"
)

// Attribute:
// {
//   @id: attrId
//   @type: T
//   <annotations>
// }
//
// "x": "y"
//
//   attrId --type--> T
//         --name--> x
//         --value--> y
//
//
//

// GraphIngester ingests a json document using the schema into a
// graph.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID
//
// The output is:
//
//     baseId (or blank) ---attributes---> attributeNode
//
// or
//
//     baseId (or blank) --attributeList -> b --first -->attributeNode
//                                         --rest --> b --> first --> attributeNode
//
//     attributeNode --value-->value
//                   --schemaId-->schemaNode
//
//     attributeNode --arrayElements-->b--first-->attributeNode
//                                      --rest --> b -->first-->attributeNode
//
type GraphIngester struct {
	schema *ls.Layer
}

func NewGraphIngester(schema *ls.Layer) *GraphIngester {
	return &GraphIngester{schema: schema}
}

func (g *GraphIngester) Ingest(output rdf.Graph, baseID string, input interface{}) error {
	if input == nil {
		return nil
	}
	var rootNode rdf.IDNode
	if len(baseID) > 0 {
		rootNode = rdf.BasicIRI(baseID)
	} else {
		rootNode = rdf.NewBasicBlankNode()
	}
	if g.schema == nil {
		triples, err := g.ingest(baseID, input, nil)
		if err != nil {
			return err
		}
		for _, x := range triples {
			output.AddTriple(x)
		}

		return nil
	}
	m, ok := input.(map[string]interface{})
	if !ok {
		return ErrNotAnObject
	}
	// Object type
	output.Add(rootNode, rdf.BasicIRI(rdf.RDFType), rdf.NewStringLiteral(g.schema.ObjectType))
	triples, err := g.ingestAttributes(baseID, m, g.schema.Root.GetAttributes())
	if err != nil {
		return err
	}
	for _, x := range triples {
		output.AddTriple(x)
	}
	return nil
}

// ingest schema information into the input graph
func (g *GraphIngester) ingest(baseID string, input interface{}, schema *ls.Attribute) ([]rdf.Triple, error) {
	if input == nil {
		return nil, nil
	}
	if m, ok := input.(map[string]interface{}); ok {
		return g.ingestObject(baseID, m, schema)
	}
	if a, ok := input.([]interface{}); ok {
		return g.ingestArray(baseID, a, schema)
	}
	return g.ingestValue(baseID, input, schema)
}

// id --- ls:value --> value
func (g *GraphIngester) ingestValue(baseID string, input interface{}, schema *ls.Attribute) ([]rdf.Triple, error) {
	var value rdf.Node
	if input == nil {
		value = rdf.BasicIRI(rdf.RDFNil)
	} else {
		value = rdf.NewStringLiteral(fmt.Sprint(input))
	}
	ret := []rdf.Triple{{
		Subject:   rdf.BasicIRI(baseID),
		Predicate: rdf.BasicIRI(ls.DocTerms.Value.GetTerm()),
		Object:    value}}

	if schema != nil {
		if schema.GetObjectType() != nil {
			return nil, ErrValidation{NodeID: baseID, Message: "Schema expects object but document has value"}
		}
		if schema.GetArrayItems() != nil {
			return nil, ErrValidation{NodeID: baseID, Message: "Schema expects array, but document has value"}
		}
		if err := validate(input, schema.Values); err != nil {
			return nil, err
		}

		if _, ok := schema.Type.(*ls.PolymorphicType); !ok {
			return append(ret, rdf.Triple{
				Subject:   rdf.BasicIRI(baseID),
				Predicate: rdf.BasicIRI(ls.DocTerms.Value.GetTerm()),
				Object:    value,
			}), nil
		}

		// A value wrt a oneOf schema. One must validate
		var validOption interface{}
		var validRet []rdf.Triple
		for _, option := range schema.GetPolymorphicOptions() {
			x, err := g.ingestValue(baseID, input, option)
			if err == nil {
				if validOption != nil {
					return nil, ErrValidation{NodeID: baseID, Message: "Multiple options match"}
				}
				validOption = option
				validRet = x
			}
		}
		if validOption == nil {
			return nil, ErrValidation{NodeID: baseID, Message: "No options match"}
		}
		return validRet, nil
	}
	return ret, nil
}

func (g *GraphIngester) ingestAttributes(baseID string, input map[string]interface{}, attributes *ls.ObjectType) ([]rdf.Triple, error) {
	schemaNodes := make(map[string]*ls.Attribute)
	if attributes != nil {
		for i := 0; i < attributes.Len(); i++ {
			attribute := attributes.Get(i)
			name := ls.AttributeAnnotations.Name.GetExpandedString(attribute.Values)
			if len(name) > 0 {
				schemaNodes[name] = attribute
			}
		}
		// Validate schema elements that are not in the document to catch possible required elements
		for k, v := range schemaNodes {
			if _, ok := input[k]; !ok {
				if err := validate(nil, v.Values); err != nil {
					return nil, err
				}
			}
		}
	}

	processed := map[string]struct{}{}
	list := rdf.ListBuilder{}
	if attributes != nil {
		for i := 0; i < attributes.Len(); i++ {
			attribute := attributes.Get(i)
			name := ls.AttributeAnnotations.Name.GetExpandedString(attribute.Values)
			if len(name) > 0 {
				if value, exists := input[name]; exists {
					processed[name] = struct{}{}
					nodeID := appendID(baseID, name)
					list.Triples = append(list.Triples, rdf.Triple{Subject: rdf.BasicIRI(baseID),
						Predicate: rdf.BasicIRI(ls.DocTerms.Attributes.GetTerm()),
						Object:    rdf.BasicIRI(nodeID)})
					list.AddNode(rdf.BasicIRI(nodeID))
					nodes, err := g.ingest(nodeID, value, attribute)
					if err != nil {
						return nil, err
					}
					list.Triples = append(list.Triples, nodes...)
				}
			}
		}
	}
	// Process elements not in the schema
	for k, v := range input {
		if _, ok := processed[k]; !ok {
			if v != nil {
				nodeID := appendID(baseID, k)
				list.AddNode(rdf.BasicIRI(nodeID))
				nodes, err := g.ingest(nodeID, v, nil)
				if err != nil {
					return nil, err
				}
				list.Triples = append(list.Triples, nodes...)
			}
		}
	}
	return append([]rdf.Triple{{
		Subject:   rdf.NewBasicBlankNode(),
		Predicate: rdf.BasicIRI(ls.DocTerms.Attributes.GetTerm()),
		Object:    list.Triples[0].Subject,
	}}, list.Triples...), nil
}

func (g *GraphIngester) ingestObject(baseID string, input map[string]interface{}, schema *ls.Attribute) ([]rdf.Triple, error) {
	ret := []rdf.Triple{}
	if schema == nil {
		for k, v := range input {
			nodeID := appendID(baseID, k)
			nodes, err := g.ingest(nodeID, v, nil)
			if err != nil {
				return nil, err
			}
			ret = append(ret, nodes...)
			ret = append(ret, rdf.Triple{Subject: rdf.BasicIRI(baseID),
				Predicate: rdf.BasicIRI(ls.DocTerms.Attributes.GetTerm()),
				Object:    rdf.BasicIRI(nodeID)})
		}
		return ret, nil
	}
	if schema.GetArrayItems() != nil {
		return nil, ErrValidation{NodeID: baseID, Message: "Schema expects array, but document has object"}
	}
	if schema.IsValue() {
		return nil, ErrValidation{NodeID: baseID, Message: "Schema expects value, but document has object"}
	}

	if attributes := schema.GetObjectType(); attributes != nil {
		if err := validate(input, schema.Values); err != nil {
			return nil, err
		}
		attrs, err := g.ingestAttributes(baseID, input, attributes)
		if err != nil {
			return nil, err
		}
		return attrs, nil
	}

	// OneOf
	var validOption interface{}
	var children []rdf.Triple
	for _, option := range schema.GetPolymorphicOptions() {
		v, err := g.ingestObject(baseID, input, option)
		if err == nil {
			if validOption != nil {
				return nil, ErrValidation{NodeID: baseID, Message: "Multiple options match"}
			}
			validOption = option
			children = v
		}
	}
	if validOption == nil {
		return nil, ErrValidation{NodeID: baseID, Message: "No options match"}
	}
	return children, nil
}

func (g *GraphIngester) ingestArray(baseID string, input []interface{}, schema *ls.Attribute) ([]rdf.Triple, error) {
	list := rdf.ListBuilder{}
	list.AddNode(rdf.BasicIRI(baseID))
	if schema != nil {
		if schema.GetObjectType() != nil {
			return nil, ErrValidation{NodeID: baseID, Message: "Schema expects object, but document has array"}
		}

		if schema.IsValue() {
			return nil, ErrValidation{NodeID: baseID, Message: "Schema expects value, but document has array"}
		}
	}

	var items *ls.Attribute
	if schema != nil {
		items = schema.GetArrayItems()
		if items != nil {
			if err := validate(input, schema.Values); err != nil {
				return nil, err
			}
		}
	}
	if schema == nil || items != nil {
		for i := range input {
			nodeId := appendID(baseID, strconv.Itoa(i))
			child, err := g.ingest(nodeId, input[i], items)
			if err != nil {
				return nil, err
			}
			list.Triples = append(list.Triples, child...)
		}
		return list.Triples, nil
	}

	// OneOf
	var validOption interface{}
	var validRet []rdf.Triple
	for _, option := range schema.GetPolymorphicOptions() {
		if v, err := g.ingestArray(baseID, input, option); err == nil {
			if validOption != nil {
				return nil, ErrValidation{NodeID: baseID, Message: "Multiple options match"}
			}
			validOption = option
			validRet = v
		}
	}
	if validOption == nil {
		return nil, ErrValidation{NodeID: baseID, Message: "No options match"}
	}
	return validRet, nil
}
