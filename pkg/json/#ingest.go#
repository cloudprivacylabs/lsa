// Copyright 2021 Cloud Privacy Labs, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package json

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"

	"github.com/bserdar/jsonom"

	"github.com/cloudprivacylabs/lsa/pkg/ls"
	"github.com/cloudprivacylabs/lsa/pkg/opencypher/graph"
)

// Ingester converts a JSON object model into a graph using a schema
type Ingester struct {
	ls.Ingester

	Interner ls.Interner
}

// IngestBytes ingests JSON bytes
func IngestBytes(context *ls.Context, ingester *Ingester, baseID string, input []byte) (graph.Node, error) {
	return IngestStream(context, ingester, baseID, bytes.NewReader(input))
}

// IngestStream ingests JSON stream
func IngestStream(context *ls.Context, ingester *Ingester, baseID string, input io.Reader) (graph.Node, error) {
	node, err := jsonom.UnmarshalReader(input, ingester.Interner)
	if err != nil {
		return nil, err
	}
	return ingester.Ingest(context, baseID, node)
}

// Ingest a json document using the schema. The output will have all
// input nodes associated with schema nodes. The ingested object is a
// single instance of an entity.
//
// BaseID is the ID of the root object. All other attribute names are
// generated by appending the attribute path to baseID. BaseID is only
// used if the schema does not explicitly specify an ID
func (ingester *Ingester) Ingest(context *ls.Context, baseID string, input jsonom.Node) (graph.Node, error) {
	ctx := ingester.Start(context, baseID)
	dn, err := ingester.ingest(ctx, input)
	if err != nil {
		return nil, err
	}
	ingester.Finish(ctx, dn)
	return dn, err
}

func (ingester *Ingester) ingest(context ls.IngestionContext, input jsonom.Node) (graph.Node, error) {
	validate := func(node graph.Node, err error) (graph.Node, error) {
		if err != nil {
			return nil, err
		}
		if err := ingester.Validate(context, node); err != nil {
			return nil, err
		}
		return node, nil
	}
	schemaNode := context.GetSchemaNode()
	// only ingest nodes that have a matching schema attribute
	if schemaNode != nil || !ingester.OnlySchemaAttributes {
		if schemaNode != nil && schemaNode.GetLabels().Has(ls.AttributeTypePolymorphic) {
			return validate(ingester.ingestPolymorphicNode(context, input))
		}
		switch next := input.(type) {
		case *jsonom.Object:
			return validate(ingester.ingestObject(context, next))
		case *jsonom.Array:
			return validate(ingester.ingestArray(context, next))
		}
		return validate(ingester.ingestValue(context, input.(*jsonom.Value)))
	}
	return nil, nil
}

func (ingester *Ingester) ingestPolymorphicNode(context ls.IngestionContext, input jsonom.Node) (graph.Node, error) {
	for edges := context.GetSchemaNode().GetEdgesWithLabel(graph.OutgoingEdge, OneOfTerm); edges.Next(); {
		edge := edges.Edge()
		optionNode := edge.GetTo()

		tw := NewTWCursor(optionNode, input)
		TandemWalkPairs(tw, func(cursor TWCursor) (bool, error) {
			// If schema node has validators, check them
			
		})
	}

	f := func(ig *ls.Ingester, ictx ls.IngestionContext) (graph.Node, error) {
		newIngester := *ingester
		newIngester.Ingester = *ig
		n, err := newIngester.ingest(ictx, input)
		if err != nil {
			return nil, err
		}
		return n, nil
	}
	node, err := ingester.Polymorphic(context, f, f)
	if err != nil {
		return nil, err
	}
	return node, nil
}

func (ingester *Ingester) ingestObject(context ls.IngestionContext, input *jsonom.Object) (graph.Node, error) {
	// An object node
	// There is a schema node for this node. It must be an object
	schemaNode := context.GetSchemaNode()
	nextNodes, err := ls.GetObjectAttributeNodesBy(schemaNode, ls.AttributeNameTerm)
	if err != nil {
		return nil, err
	}
	_, _, node, err := ingester.Object(context)
	if err != nil {
		return nil, err
	}
	ictx := context.NewLevel(node)
	for i := 0; i < input.Len(); i++ {
		keyValue := input.N(i)
		schNodes := nextNodes[keyValue.Key()]
		if len(schNodes) > 1 {
			return nil, ls.ErrInvalidSchema(fmt.Sprintf("Multiple elements with key '%s'", keyValue.Key()))
		}
		var schNode graph.Node
		if len(schNodes) == 1 {
			schNode = schNodes[0]
		}
		childNode, err := ingester.ingest(ictx.New(keyValue.Key(), schNode), keyValue.Value())
		if err != nil {
			return nil, ls.ErrDataIngestion{Key: keyValue.Key(), Err: err}
		}
		if childNode != nil {
			childNode.SetProperty(ls.AttributeNameTerm, ls.StringPropertyValue(keyValue.Key()))
		}
	}
	return node, err
}

func (ingester *Ingester) ingestArray(context ls.IngestionContext, input *jsonom.Array) (graph.Node, error) {
	schemaNode := context.GetSchemaNode()
	elementsNode := ls.GetArrayElementNode(schemaNode)
	_, _, node, err := ingester.Array(context)
	if err != nil {
		return nil, err
	}
	ictx := context.NewLevel(node)
	for index := 0; index < input.Len(); index++ {
		childNode, err := ingester.ingest(ictx.New(index, elementsNode), input.N(index))
		if err != nil {
			return nil, ls.ErrDataIngestion{Key: fmt.Sprint(index), Err: err}
		}
		if childNode != nil {
			childNode.SetProperty(ls.AttributeIndexTerm, ls.StringPropertyValue(fmt.Sprint(index)))
		}
	}
	return node, err
}

func (ingester *Ingester) ingestValue(context ls.IngestionContext, input *jsonom.Value) (graph.Node, error) {
	if !ingester.IngestEmptyValues && input == nil {
		return nil, nil
	}
	var value string
	var typ string
	if input.Value() != nil {
		switch v := input.Value().(type) {
		case bool:
			value = fmt.Sprint(v)
			typ = BooleanTypeTerm
		case string:
			value = v
			typ = StringTypeTerm
		case uint8, uint16, uint32, uint64, int8, int16, int32, int64, int, uint, float32, float64:
			value = fmt.Sprint(input.Value())
			typ = NumberTypeTerm
		case json.Number:
			value = string(v)
			typ = NumberTypeTerm
		default:
			value = fmt.Sprint(v)
		}
	}
	_, _, node, err := ingester.Value(context, value, typ)
	return node, err
}
